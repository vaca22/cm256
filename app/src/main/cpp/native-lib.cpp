#include <jni.h>
#include <string>
#include "cm256.h"

extern "C" JNIEXPORT jstring JNICALL
Java_com_vaca_cm256_MainActivity_stringFromJNI(
        JNIEnv* env,
        jobject /* this */) {
    cm256_init();
    cm256_encoder_params params;

    // Number of bytes per file block
    params.BlockBytes = 1296;

    // Number of blocks
    params.OriginalCount = 100;

    // Number of additional recovery blocks generated by encoder
    params.RecoveryCount = 30;

    // Size of the original file
    static const int OriginalFileBytes = params.OriginalCount * params.BlockBytes;

    // Allocate and fill the original file data
    uint8_t* originalFileData = new uint8_t[OriginalFileBytes];
    for (int i = 0; i < OriginalFileBytes; ++i)
    {
        originalFileData[i] = (uint8_t)i;
    }

    // Pointers to data
    cm256_block blocks[256];
    for (int i = 0; i < params.OriginalCount; ++i)
    {
        blocks[i].Block = originalFileData + i * params.BlockBytes;
    }

    // Recovery data
    uint8_t* recoveryBlocks = new uint8_t[params.RecoveryCount * params.BlockBytes];

    // Generate recovery data
    cm256_encode(params, blocks, recoveryBlocks);

    // Initialize the indices
    for (int i = 0; i < params.OriginalCount; ++i)
    {
        blocks[i].Index = cm256_get_original_block_index(params, i);
    }

    //// Simulate loss of data, substituting a recovery block in its place ////
    for (int i = 0; i < params.RecoveryCount-5 && i < params.OriginalCount; ++i)
    {
        blocks[i].Block = recoveryBlocks + params.BlockBytes * (params.RecoveryCount-i-2); // First recovery block
        blocks[i].Index = cm256_get_recovery_block_index(params, params.RecoveryCount-i-2); // First recovery block index
    }
    //// Simulate loss of data, substituting a recovery block in its place ////

    cm256_decode(params, blocks);
    std::string hello = "Hello from C++";
    for (int i = 0; i < params.OriginalCount; ++i)
    {
        uint8_t* block = (uint8_t*)blocks[i].Block;
        int index = blocks[i].Index;

        for (int j = 0; j < params.BlockBytes; ++j)
        {
            const uint8_t expected = (uint8_t)(j + index * params.BlockBytes);
            if (block[j] != expected)
            {
                hello.append("fuck");
            }
        }
    }

    delete[] originalFileData;
    delete[] recoveryBlocks;

    return env->NewStringUTF(hello.c_str());
}